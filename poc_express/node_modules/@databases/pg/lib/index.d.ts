import { isSQLError, SQLError, SQLErrorCode } from '@databases/pg-errors';
import sql, { SQLQuery, SQL } from '@databases/sql';
import { TConfig } from 'pg-promise';
import DataTypeID from '@databases/pg-data-type-id';
export { sql, SQLQuery, isSQLError, SQLError, SQLErrorCode, DataTypeID };
export interface Connection {
    readonly sql: SQL;
    query(query: SQLQuery): Promise<any[]>;
    task<T>(fn: (connection: Connection) => Promise<T>): Promise<T>;
    tx<T>(fn: (connection: Connection) => Promise<T>): Promise<T>;
}
export interface RootConnection extends Connection {
    dispose(): Promise<void>;
    registerTypeParser<T>(type: number | string, parser: (value: string) => T): Promise<(value: string) => T>;
    getTypeParser(type: number | string): Promise<(value: string) => any>;
    /**
     * Parses an n-dimensional array
     *
     * @param value The string value from the database
     * @param entryParser A transform function to apply to each string
     */
    parseArray(value: string, entryParser?: (entry: string | null) => any): any[];
    /**
     * Parse a composite value and get a tuple of strings where
     * each string represents one attribute.
     *
     * @param value The raw string.
     */
    parseComposite(value: string): string[];
}
export declare function isRootConnection(c: Connection | RootConnection): c is RootConnection;
export declare type ConnectionParamNames = 'database' | 'user' | 'password' | 'port' | 'host' | 'ssl';
export declare const ConnectionParamNames: string[];
export declare type ConnectionParams = Pick<TConfig, ConnectionParamNames>;
export interface ConnectionOptions extends Pick<TConfig, Exclude<keyof TConfig, ConnectionParamNames>> {
    bigIntAsString?: boolean;
}
export default function createConnection(connectionConfig?: string | ConnectionParams | undefined, { bigIntAsString, ...otherOptions }?: ConnectionOptions): RootConnection;
