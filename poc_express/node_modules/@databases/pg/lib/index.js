"use strict";

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = undefined && undefined.__rest || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const pg_errors_1 = require("@databases/pg-errors");
exports.isSQLError = pg_errors_1.isSQLError;
exports.SQLErrorCode = pg_errors_1.SQLErrorCode;
const sql_1 = require("@databases/sql");
exports.sql = sql_1.default;
exports.SQLQuery = sql_1.SQLQuery;
const pg = require("pg-promise");
const pg_data_type_id_1 = require("@databases/pg-data-type-id");
exports.DataTypeID = pg_data_type_id_1.default;
const pg_config_1 = require("@databases/pg-config");
const { codeFrameColumns } = require('@babel/code-frame');
const { connectionStringEnvironmentVariable } = pg_config_1.getPgConfigSync();
class ConnectionImplementation {
    constructor(connection) {
        this.sql = sql_1.default;
        this.connection = connection;
    }
    query(query) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(query instanceof sql_1.SQLQuery)) {
                throw new Error('Invalid query, you must use @databases/sql to create your queries.');
            }
            const q = query.compile(process.env.NODE_ENV !== 'production' ? { minify: false } : undefined);
            try {
                return yield this.connection.query(q);
            } catch (ex) {
                if (pg_errors_1.isSQLError(ex) && ex.position) {
                    const position = parseInt(ex.position, 10);
                    const match = /syntax error at or near \"([^\"\n]+)\"/.exec(ex.message) || /relation \"([^\"\n]+)\" does not exist/.exec(ex.message);
                    let column = 0;
                    let line = 1;
                    for (let i = 0; i < position; i++) {
                        if (q.text[i] === '\n') {
                            line++;
                            column = 0;
                        } else {
                            column++;
                        }
                    }
                    const start = { line, column };
                    let end;
                    if (match) {
                        end = { line, column: column + match[1].length };
                    }
                    ex.message += `\n\n${codeFrameColumns(q.text, { start, end })}\n`;
                }
                throw ex;
            }
        });
    }
    task(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.connection.task(t => {
                return fn(new ConnectionImplementation(t));
            });
        });
    }
    tx(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.connection.tx(t => {
                return fn(new ConnectionImplementation(t));
            });
        });
    }
}
class RootConnectionImplementation extends ConnectionImplementation {
    constructor(connection, pgp) {
        super(connection);
        this.sql = sql_1.default;
        this.dispose = () => connection.$pool.end();
        this.pgp = pgp;
    }
    _getTypeID(type) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof type === 'number') {
                return type;
            }
            const ts = type.split('.');
            let results;
            if (ts.length === 1) {
                results = yield this.query(sql_1.default`
        SELECT
          ty.oid as "typeID",
          ns.nspname AS "schemaName",
          ty.typname AS "typeName"
        FROM pg_catalog.pg_type ty
        INNER JOIN pg_catalog.pg_namespace ns
          ON (ty.typnamespace = ns.oid)
        WHERE lower(ty.typname) = ${type.toLowerCase()};
      `);
            } else if (ts.length === 2) {
                results = yield this.query(sql_1.default`
        SELECT
          ty.oid as "typeID",
          ns.nspname AS "schemaName",
          ty.typname AS "typeName"
        FROM pg_catalog.pg_type ty
        INNER JOIN pg_catalog.pg_namespace ns
          ON (ty.typnamespace = ns.oid)
        WHERE lower(ty.typname) = ${ts[1].toLowerCase()} AND lower(ns.nspname) = ${ts[0].toLowerCase()};
      `);
            } else {
                throw new Error('Type Name should only have one "." in it');
            }
            if (results.length === 0) {
                throw new Error('Could not find the type ' + type);
            }
            if (results.length > 1) {
                throw new Error('The type name ' + type + ' was found in multiple schemas: ' + results.map(r => r.schemaName).join(', '));
            }
            return results[0].typeID;
        });
    }
    registerTypeParser(type, parser) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeID = yield this._getTypeID(type);
            this.pgp.pg.types.setTypeParser(typeID, parser);
            return parser;
        });
    }
    getTypeParser(type) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeID = yield this._getTypeID(type);
            return this.pgp.pg.types.getTypeParser(typeID);
        });
    }
    /**
     * Parses an n-dimensional array
     *
     * @param value The string value from the database
     * @param entryParser A transform function to apply to each string
     */
    parseArray(value, entryParser) {
        return this.pgp.pg.types.arrayParser.create(value, entryParser).parse();
    }
    /**
     * Parse a composite value and get a tuple of strings where
     * each string represents one attribute.
     *
     * @param value The raw string.
     */
    parseComposite(value) {
        if (value[0] !== '(') {
            throw new Error('composite values should start with (');
        }
        const values = [];
        let currentValue = '';
        let quoted = false;
        for (let i = 1; i < value.length; i++) {
            if (!quoted && value[i] === ',') {
                values.push(currentValue);
                currentValue = '';
                continue;
            } else if (!quoted && value[i] === ')') {
                values.push(currentValue);
                currentValue = '';
                if (i !== value.length - 1) {
                    throw new Error('Got ")" before end of value');
                }
                continue;
            } else if (quoted && value[i] === '"') {
                if (value[i + 1] === '"') {
                    // if the next value is also a quote, that means we
                    // are looking at an escaped quote. Skip this char
                    // and insert the quote
                    i++;
                } else {
                    quoted = false;
                    continue;
                }
            } else if (value[i] === '"') {
                quoted = true;
                continue;
            }
            currentValue += value[i];
        }
        if (currentValue) {
            throw new Error('Got to end of value with no ")"');
        }
        return values;
    }
}
function isRootConnection(c) {
    return c instanceof RootConnectionImplementation;
}
exports.isRootConnection = isRootConnection;
exports.ConnectionParamNames = ['database', 'user', 'password', 'port', 'host', 'ssl'];
function createConnection(connectionConfig = process.env[connectionStringEnvironmentVariable], _a = {}) {
    var { bigIntAsString } = _a,
        otherOptions = __rest(_a, ["bigIntAsString"]);
    if (!connectionConfig) {
        throw new Error('You must provide a connection string for @databases/pg. You can ' + 'either pass one directly to the createConnection call or set ' + `the ${connectionStringEnvironmentVariable} environment variable.`);
    }
    if (typeof connectionConfig === 'string') {
        let url;
        try {
            url = new URL(connectionConfig);
        } catch (ex) {
            throw new Error('Invalid Postgres connection string, expected a URI: ' + connectionConfig);
        }
        if (url.protocol !== 'postgres:') {
            throw new Error('Invalid Postgres connection string, expected protocol to be "postgres": ' + connectionConfig);
        }
    }
    if (typeof connectionConfig === 'object') {
        Object.keys(connectionConfig).forEach(key => {
            if (!exports.ConnectionParamNames.includes(key)) {
                throw new Error(`${key} is not a supported key for ConnectionConfig`);
            }
        });
    }
    const pgp = pg();
    // By default we force BIG_INTEGER to return as a JavaScript number because
    // we never expect to handle integers larger than 2^52, but want to allow
    // numbers greater than 2^32 in the database
    if (!bigIntAsString) {
        // BIGINT -> INT
        const parseInteger = pgp.pg.types.getTypeParser(pg_data_type_id_1.default.int4);
        const MAX_SAFE_INTEGER = `${Number.MAX_SAFE_INTEGER}`;
        pgp.pg.types.setTypeParser(pg_data_type_id_1.default.int8, str => {
            if (str && str.length > MAX_SAFE_INTEGER.length || str.length === MAX_SAFE_INTEGER.length && str > MAX_SAFE_INTEGER) {
                throw new Error(`JavaScript cannot handle integers great than: ${Number.MAX_SAFE_INTEGER}`);
            }
            return parseInteger(str);
        });
        // BIGINT ARRAY -> INT ARRAY
        const parseIntegerArray = pgp.pg.types.getTypeParser(pg_data_type_id_1.default.int4);
        pgp.pg.types.setTypeParser(pg_data_type_id_1.default._int8, str => {
            const result = parseIntegerArray(str);
            if (result && result.some(val => val && val > Number.MAX_SAFE_INTEGER)) {
                throw new Error(`JavaScript cannot handle integers great than: ${Number.MAX_SAFE_INTEGER}`);
            }
        });
    }
    // tslint:disable-next-line:no-unbound-method
    // const originalWarn = console.warn;
    if (process.env.NODE_ENV === 'test' || true) {
        console.warn = () => {
            // ignore warnings
        };
    }
    const c = typeof connectionConfig === 'object' ? Object.assign({}, connectionConfig, otherOptions) : Object.assign({ connectionString: connectionConfig }, otherOptions);
    const connection = pgp(Object.assign({}, c, { noWarnings: true }));
    // if (process.env.NODE_ENV === 'test' || true) {
    //   console.warn = originalWarn;
    // }
    return new RootConnectionImplementation(connection, pgp);
}
exports.default = createConnection;
module.exports = createConnection;
module.exports.default = createConnection;
module.exports.sql = sql_1.default;
module.exports.SQLQuery = sql_1.SQLQuery;
module.exports.isSQLError = pg_errors_1.isSQLError;
module.exports.SQLErrorCode = pg_errors_1.SQLErrorCode;
module.exports.DataTypeID = pg_data_type_id_1.default;
//# sourceMappingURL=index.js.map