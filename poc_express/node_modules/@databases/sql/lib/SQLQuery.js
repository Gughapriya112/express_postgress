"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const minify = require("pg-minify");
var SQLItemType;
(function (SQLItemType) {
    SQLItemType[SQLItemType["RAW"] = 0] = "RAW";
    SQLItemType[SQLItemType["VALUE"] = 1] = "VALUE";
    SQLItemType[SQLItemType["IDENTIFIER"] = 2] = "IDENTIFIER";
})(SQLItemType || (SQLItemType = {}));
const formatter = Symbol('SQL Query Formatter');
const DEFAULT_COMPILE_OPTIONS = { minify: true };
/**
 * The representation of a SQL query. Call `compile` to turn it into a SQL
 * string with value placeholders.
 *
 * This object is immutable. Instead of changing the object, new `SQLQuery`
 * values will be returned.
 *
 * The constructor for this class is private and may not be called.
 */
class SQLQuery {
    // The constructor is private. Users should use the static `create` method to
    // make a new `SQLQuery`.
    constructor(items) {
        /**
         * To implement PGQuery
         */
        this.minified = true;
        /**
         * Storage for our memoized compiled query.
         */
        this._pgQuery = null;
        /**
         * Storage for our memoized compiled query.
         */
        this._mysqlQuery = null;
        this._items = items;
    }
    static registerFormatter(constructor, format) {
        constructor.prototype[formatter] = format;
    }
    /**
     * A template string tag that interpolates literal SQL with placeholder SQL
     * values.
     */
    static query(strings, ...values) {
        const items = [];
        // Add all of the strings as raw items and values as placeholder values.
        for (let i = 0; i < strings.length; i++) {
            if (strings[i]) {
                items.push({ type: SQLItemType.RAW, text: strings[i] });
            }
            if (i < values.length) {
                const value = values[i];
                // If the value is a `SQLQuery`, add all of its items.
                if (value instanceof SQLQuery) {
                    for (const item of value._items) items.push(item);
                } else {
                    if (value && typeof value === 'object' && formatter in value) {
                        const formatted = value[formatter](value);
                        if (!(formatted instanceof SQLQuery)) {
                            throw new Error('Formatters should always return SQLQuery objects');
                        }
                        for (const item of formatted._items) items.push(item);
                    } else {
                        items.push({ type: SQLItemType.VALUE, value });
                    }
                }
            }
        }
        return new SQLQuery(items);
    }
    /**
     * Joins multiple queries together and puts a seperator in between if a
     * seperator was defined.
     */
    static join(queries, seperator) {
        const items = [];
        // Add the items of all our queries into the `items` array, adding text
        // seperator items as necessary.
        for (const query of queries) {
            for (const item of query._items) items.push(item);
            // If we have a seperator, and this is not the last query, add a
            // seperator.
            if (seperator && query !== queries[queries.length - 1]) items.push({ type: SQLItemType.RAW, text: seperator });
        }
        return new SQLQuery(items);
    }
    /**
     * Creates a new query with the raw text.
     */
    static raw(text) {
        return new SQLQuery([{ type: SQLItemType.RAW, text }]);
    }
    /**
     * Creates a new query with the value. This value will be turned into a
     * placeholder when the query gets compiled.
     */
    static value(value) {
        return new SQLQuery([{ type: SQLItemType.VALUE, value }]);
    }
    /**
     * Creates an identifier query. Each name will be escaped, and the
     * names will be concatenated with a period (`.`).
     */
    static ident(...names) {
        return new SQLQuery([{ type: SQLItemType.IDENTIFIER, names }]);
    }
    /**
     * The SQL query text with placeholders for values. The placeholders refer to
     * a value in the `values` array.
     */
    get text() {
        return this.compile().text;
    }
    /**
     * The values used to fill the placeholders in `text`.
     */
    get values() {
        return this.compile().values;
    }
    /**
     * Compiles this SQL query into a Postgres query. Memoized so it only does the
     * work once.
     */
    compile(options = DEFAULT_COMPILE_OPTIONS) {
        // If we don’t yet have a compiled query, create one.
        if (this._pgQuery == null || this._pgQuery.minified !== options.minify) {
            this._pgQuery = compilePG(this._items, options);
        }
        return this._pgQuery;
    }
    /**
     * Compiles this SQL query into a Postgres query. Memoized so it only does the
     * work once.
     */
    compileMySQL() {
        // If we don’t yet have a compiled query, create one.
        if (this._mysqlQuery == null) {
            this._mysqlQuery = compileMySQL(this._items);
        }
        return this._mysqlQuery;
    }
}
exports.default = SQLQuery;
/**
 * Compiles a list of `SQLItem`s into a single `PGQuery`.
 */
function compilePG(items, options) {
    // Create an empty query object.
    const query = {
        text: '',
        values: [],
        minified: false
    };
    const localIdentifiers = new Map();
    for (const item of items) {
        switch (item.type) {
            // If this is just raw text, we add it directly to the query text.
            case SQLItemType.RAW:
                {
                    query.text += item.text;
                    break;
                }
            // If we got a value SQL item, add a placeholder and add the value to our
            // placeholder values array.
            case SQLItemType.VALUE:
                {
                    query.text += `$${query.values.length + 1}`;
                    query.values.push(item.value);
                    break;
                }
            // If we got an identifier type, escape the strings and get a local
            // identifier for non-string identifiers.
            case SQLItemType.IDENTIFIER:
                {
                    query.text += item.names.map(name => {
                        if (typeof name === 'string') return escapePGIdentifier(name);
                        if (!localIdentifiers.has(name)) localIdentifiers.set(name, `__local_${localIdentifiers.size}__`);
                        return localIdentifiers.get(name);
                    }).join('.');
                    break;
                }
        }
    }
    // Minify the query text before returning it.
    if (options.minify) {
        query.text = minify(query.text);
        query.minified = true;
    }
    return query;
}
function compileMySQL(items) {
    // Create an empty query object.
    const query = {
        text: '',
        values: []
    };
    const localIdentifiers = new Map();
    for (const item of items) {
        switch (item.type) {
            // If this is just raw text, we add it directly to the query text.
            case SQLItemType.RAW:
                {
                    query.text += item.text;
                    break;
                }
            // If we got a value SQL item, add a placeholder and add the value to our
            // placeholder values array.
            case SQLItemType.VALUE:
                {
                    query.text += `?`;
                    query.values.push(item.value);
                    break;
                }
            // If we got an identifier type, escape the strings and get a local
            // identifier for non-string identifiers.
            case SQLItemType.IDENTIFIER:
                {
                    query.text += item.names.map(name => {
                        if (typeof name === 'string') return escapeMySqlIdentifier(name);
                        if (!localIdentifiers.has(name)) localIdentifiers.set(name, `__local_${localIdentifiers.size}__`);
                        return localIdentifiers.get(name);
                    }).join('.');
                    break;
                }
        }
    }
    query.text = query.text.trim();
    return query;
}
/**
 * Escapes a Postgres identifier. Adapted from the [`pg` module][1].
 *
 * [1]: https://github.com/brianc/node-postgres/blob/a536afb1a8baa6d584bd460e7c1286d75bb36fe3/lib/client.js#L255-L272
 */
function escapePGIdentifier(str) {
    if (!str) {
        throw new Error('Postgres identifiers must be at least 1 character long.');
    }
    if (str.length > 63) {
        throw new Error('Postgres identifiers should not be longer than 63 characters. https://www.postgresql.org/docs/9.3/sql-syntax-lexical.html');
    }
    if (!/^[A-Za-z0-9_]*$/.test(str)) {
        throw new Error('@database/sql restricts postgres identifiers to alphanumeric characers and underscores.');
    }
    let escaped = '"';
    for (const c of str) {
        if (c === '"') escaped += c + c;else escaped += c;
    }
    escaped += '"';
    return escaped;
}
/**
 * Escapes a MySQL identifier.
 *
 * https://www.codetinkerer.com/2015/07/08/escaping-column-and-table-names-in-mysql-part2.html
 */
function escapeMySqlIdentifier(str) {
    if (!str) {
        throw new Error('MySQL identifiers must be at least 1 character long.');
    }
    if (str.length > 64) {
        throw new Error('MySQL identifiers should not be longer than 64 characters. http://dev.mysql.com/doc/refman/5.7/en/identifiers.html');
    }
    if (str[str.length - 1] === ' ') {
        throw new Error('MySQL identifiers may not end in whitespace');
    }
    if (!/^[A-Za-z0-9_]*$/.test(str)) {
        throw new Error('@database/sql restricts mysql identifiers to alphanumeric characers and underscores.');
    }
    let escaped = '`';
    for (const c of str) {
        if (c === '`') escaped += c + c;else escaped += c;
    }
    escaped += '`';
    return escaped;
}
//# sourceMappingURL=SQLQuery.js.map